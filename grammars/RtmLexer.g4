lexer grammar RtmLexer;

channels {
	COMMENTS_CHANNEL
}

SOURCE_DESCRIPTION: ('RTM' | 'ZUG') INPUTCHARACTER* -> mode(SOURCE);
NON_SOURCE: . -> more, mode(TEXT_MODE);

mode TEXT_MODE;
FREE_TEXT: (.*? NL)+;

mode SOURCE;
DOLLAR_ENTRY: '$ENTRY' {Column == 6}?;
DOLLAR_FILES: '$FILES' {Column == 6}?;
DOLLAR_DATA: '$DATA' {Column == 5}? -> pushMode(DATA_AREA);
DOLLAR_EXTDATA: '$EXTDATA' {Column == 8}? -> pushMode(DATA_AREA);
DOLLAR_SCRNDATA: '$SCRNDATA' {Column == 9}? -> pushMode(DATA_AREA);
DOLLAR_USERDATA: '$USERDATA' {Column == 9}? -> pushMode(DATA_AREA);
DOLLAR_EXT: '$EXT' {Column == 4}?;
DOLLAR_PROG: '$PROG' {Column == 5}?;
DOLLAR_ABORT: '$ABORT' {Column == 6}?;
DOLLAR_INCLUDE: '$INCLUDE' {Column == 8}?;
DOLLAR_NAME: '$NAME' {Column == 5}? -> pushMode(NAME_DECLARE);
DOLLAR_END: '$END' {Column == 4}? -> mode(END_OF_SOURCE);
FULL_LINE_COMMENT:
	'*' {Column == 1}? INPUTCHARACTER* -> channel(COMMENTS_CHANNEL);
INLINE_COMMENT:
	'<<' -> pushMode(COMMENT_MODE), channel(COMMENTS_CHANNEL);

LB: '(';
RB: ')';
COLON: ':';
SEMI_COLON: ';';
COMMA: ',';
HAT: '^';
LSB: '[';
RSB: ']';

//Assignments
ASSIGN: '_';
INCREMENT: '++';
DECREMENT: '--';
ADD_TO: '+_';

//Arithmetic
PLUS: '+';
MINUS: '-';
STAR: '*';
SLASH: '/';
DOUBLE_SLASH: '//';
SLASH_COLON: '/:';

//Logical
BIT_AND: '&';
BIT_OR: '!';
BIT_XOR: '%';
BIT_SHIFT_LEFT: '<:';
BIT_SHIFT_RIGHT: ':>';

//Relations
EQUAL: '=';
NOT_EQUAL: '#';
LESS_THAN: '<';
MORE_THAN: '>';
LESS_OR_EQUAL: '<=';
MORE_OR_EQUAL: '>=';

//Literals
NUMERIC_LITERAL: [0-9]+;
STRING_LITERAL: '"' ~["\r\n\u0085\u2028\u2029]* '"';
DATE_LITERAL: STRING_LITERAL 'D'; //handle other date masks
HEX_LITERAL: STRING_LITERAL 'X';
KEY_LITERAL: STRING_LITERAL 'K';

//Keywords
OVERLAY: 'OVERLAY';
PROC: 'PROC';
RETURN: 'RETURN';
ENDPROC: 'ENDPROC';
QUITZUG: 'QUITZUG';
DO: 'DO';
END: 'END';
CASE: 'CASE';
ENDCASE: 'ENDCASE';
ALWAYS: 'ALWAYS';
NEVER: 'NEVER';
UNTIL: 'UNTIL';
WHILE: 'WHILE';
REPEAT: 'REPEAT';
IF: 'IF';
THEN: 'THEN';
ELSE: 'ELSE';
AND: 'AND';
OR: 'OR';
DIE: 'DIE';

ARRAY_SIZE: NUMERIC_LITERAL -> type(NUMERIC_LITERAL);

FIELD_ID: [WFHG] [0-9]? '$' ID;
AT_VARIABLE: '@' [0-4AB];
ID: [@a-zA-Z] [@a-zA-Z0-9.]*;
RTMFILE_NAME: '$' ID;
IGNORED_RETURN: '\'' (FIELD_ID | ID);

WS: [ \t] -> channel(HIDDEN);
NL:
	(
		'\r\n'
		| '\r'
		| '\n'
		| '\u0085' // <Next Line CHARACTER (U+0085)>'
		| '\u2028' //'<Line Separator CHARACTER (U+2028)>'
		| '\u2029'
	); //'<Paragraph Separator CHARACTER (U+2029)>'

ERROR_CHAR:
	.; //If no other tokens match. Ensures lexer does not fail and error can be handled in parser.

mode DATA_AREA;
SHARED: 'SHARED';
PREFIX: 'PREFIX';
FILL: 'FILL';
DATA_INCLUDE: DOLLAR_INCLUDE -> type(DOLLAR_INCLUDE);
DATA_ID_OR_MASK: '@'? [a-zA-Z] [\-a-zA-Z0-9.]*;
COPY_MASK: '\'' WS? (FIELD_ID | ID);
DATA_FIELD_ID: FIELD_ID -> type(FIELD_ID);
CODE_STRING_START: 'C^' -> pushMode(CODE_STRING);
DATA_DOLLAR_DATA: DOLLAR_DATA -> type(DOLLAR_DATA);
DATA_DOLLAR_EXTDATA: DOLLAR_EXTDATA -> type(DOLLAR_EXTDATA);
DATA_DOLLAR_SCRNDATA: DOLLAR_SCRNDATA -> type(DOLLAR_SCRNDATA);
DATA_DOLLAR_USERDATA: DOLLAR_USERDATA -> type(DOLLAR_USERDATA);
DATA_EXT: DOLLAR_EXT -> type(DOLLAR_EXT), popMode;
DATA_PROG: DOLLAR_PROG -> type(DOLLAR_PROG), popMode;
DATA_EQUAL: EQUAL -> type(EQUAL);
DATA_COMMA: COMMA -> type(COMMA);
DATA_LB: LB -> type(LB);
DATA_RB: RB -> type(RB);
DATA_LSB: LSB -> type(LSB);
DATA_RSB: RSB -> type(RSB);
DATA_STAR: STAR -> type(STAR);
DATA_ARRAY_SIZE: NUMERIC_LITERAL -> type(NUMERIC_LITERAL);
DATA_NEWLINE: NL -> type(NL);
DATA_WHITESPACE: WS+? -> skip;
DATA_FULL_LINE_COMMENT:
	FULL_LINE_COMMENT -> channel(COMMENTS_CHANNEL), type(FULL_LINE_COMMENT);
DATA_END_LINE_COMMENT:
	INLINE_COMMENT -> channel(COMMENTS_CHANNEL), type(INLINE_COMMENT), pushMode(COMMENT_MODE);
DATA_ERROR_CHAR: ERROR_CHAR -> type(ERROR_CHAR);

mode CODE_STRING;
CODE_STRING_DELIM: HAT -> type(HAT);
CODE_STRING_END: HAT HAT -> popMode;
CODE_STRING_WHITESPACE: WS+ -> type(WS);
CODE_STRING_VALUE: NON_HAT_CHARACTER+?;
CODE_STRING_NEWLINE: NL -> type(NL);
CODE_STRING_FULL_LINE_COMMENT:
	FULL_LINE_COMMENT -> type(FULL_LINE_COMMENT), channel(COMMENTS_CHANNEL);
CODE_STRING_INLINE_COMMENT:
	'<<' -> type(INLINE_COMMENT), pushMode(COMMENT_MODE), channel(COMMENTS_CHANNEL);

mode NAME_DECLARE;
NAME_ID: ID -> type(ID), popMode, pushMode(NAME_BODY);
NAME_END: '...' '.'* -> popMode;
NAME_WHITESPACE: WS+ -> type(WS), channel(HIDDEN);
NAME_DECLARE_ERROR_CHAR: ERROR_CHAR -> type(ERROR_CHAR);

mode NAME_BODY;
NAME_TEXT: . -> type(FREE_TEXT);
NAME_DOLLAR_NAME:
	DOLLAR_NAME -> type(DOLLAR_NAME), popMode, pushMode(NAME_DECLARE);

mode END_OF_SOURCE;
END_TEXT:
	FREE_TEXT -> type(FREE_TEXT), channel(COMMENTS_CHANNEL);

mode COMMENT_MODE;
COMMENT_END1:
	'>>' -> type(INLINE_COMMENT), channel(COMMENTS_CHANNEL), popMode;
COMMENT_TEXT_SINGLE_ARROW:
	'>' -> type(INLINE_COMMENT), channel(COMMENTS_CHANNEL);
COMMENT_END2: NL -> type(NL), popMode;
COMMENT_TEXT:
	NON_RIGHT_ARROW_CHARACTER+ -> type(INLINE_COMMENT), channel(COMMENTS_CHANNEL);
COMMENT_MODE_ERROR_CHAR: ERROR_CHAR -> type(ERROR_CHAR);

//fragments
fragment INPUTCHARACTER: ~[\r\n\u0085\u2028\u2029];
fragment NON_RIGHT_ARROW_CHARACTER: ~[>\r\n\u0085\u2028\u2029];
fragment NON_HAT_CHARACTER: ~[^\r\n\u0085\u2028\u2029];