lexer grammar RtmLexer;

channels {
	COMMENTS_CHANNEL
}

SOURCE_TYPE: ('RTM' | 'ZUG') -> pushMode(SOURCE_DESCRIPTION);
NON_SOURCE: . -> more, pushMode(TEXT);

mode SOURCE_DESCRIPTION;
SOURCE_DESC_END: NEWLINE -> skip, pushMode(SOURCE);
SOURCE_DESC_FULL_LINE_COMMENT:
	FULL_LINE_COMMENT -> type(FULL_LINE_COMMENT), pushMode(SOURCE);
SOURCE_DESC: INPUTCHARACTER+ -> pushMode(SOURCE);
SOURCE_ERROR_CHAR: ERROR_CHAR -> type(ERROR_CHAR);

mode TEXT;
FREE_TEXT: INPUTCHARACTER* (NEWLINE | EOF);

mode SOURCE;
FULL_LINE_COMMENT:
	NEWLINE '*' INPUTCHARACTER* -> channel(COMMENTS_CHANNEL);
INLINE_COMMENT:
	'<<' -> pushMode(COMMENT_MODE_SKIP_NEWLINE), channel(COMMENTS_CHANNEL);

DOLLAR_ENTRY: '$ENTRY';
DOLLAR_FILES: '$FILES';
DOLLAR_DATA: '$DATA' -> pushMode(DATA_AREA);
DOLLAR_EXTDATA: '$EXTDATA' -> pushMode(DATA_AREA);
DOLLAR_SCRNDATA: '$SCRNDATA' -> pushMode(DATA_AREA);
DOLLAR_USERDATA: '$USERDATA' -> pushMode(DATA_AREA);
DOLLAR_EXT: '$EXT';
DOLLAR_INCLUDE: '$INCLUDE';
DOLLAR_NAME: '$NAME' -> pushMode(NAME_DECLARE);
DOLLAR_PROG: '$PROG';
DOLLAR_ABORT: '$ABORT';
DOLLAR_END: '$END' -> pushMode(END_OF_SOURCE);

LB: '(';
RB: ')';
COLON: ':';
SEMI_COLON: ';';
COMMA: ',';
HAT: '^';
AT: '@';
LSB: '[';
RSB: ']';
DOT: '.';
ELLIPSIS: '...';

//Assignments
ASSIGN: '_';
INCREMENT: '++';
DECREMENT: '--';
ADD_TO: '+_';

//Arithmetic
PLUS: '+';
MINUS: '-';
STAR: '*';
SLASH: '/';
DOUBLE_SLASH: '//';
SLASH_COLON: '/:';

//Logical
BIT_AND: '&';
BIT_OR: '!';
BIT_XOR: '%';
BIT_SHIFT_LEFT: '<:';
BIT_SHIFT_RIGHT: ':>';

//Relations
EQUAL: '=';
NOT_EQUAL: '#';
LESS_THAN: '<';
MORE_THAN: '>';
LESS_OR_EQUAL: '<=';
MORE_OR_EQUAL: '>=';

//Literals
NUMERIC_LITERAL: [0-9]+;
STRING_LITERAL: '"' ~["\r\n\u0085\u2028\u2029]* '"';
DATE_LITERAL: STRING_LITERAL 'D'; //handle other date masks
HEX_LITERAL: STRING_LITERAL 'X';
KEY_LITERAL: STRING_LITERAL 'K';

//Keywords
OVERLAY: 'OVERLAY';
PROC: 'PROC';
RETURN: 'RETURN';
ENDPROC: 'ENDPROC';
QUITZUG: 'QUITZUG';
DO: 'DO';
END: 'END';
CASE: 'CASE';
ENDCASE: 'ENDCASE';
ALWAYS: 'ALWAYS';
NEVER: 'NEVER';
UNTIL: 'UNTIL';
WHILE: 'WHILE';
REPEAT: 'REPEAT';
IF: 'IF';
THEN: 'THEN';
ELSE: 'ELSE';
AND: 'AND';
OR: 'OR';
SHARED: 'SHARED';
DIE: 'DIE';

FIELD_IDENTIFIER: [WFHG] [0-9]? '$' IDENTIFIER;
AT_VARIABLE: '@' [0-4AB];
IDENTIFIER: [@a-zA-Z] [@a-zA-Z0-9.]*;
RTMFILE_NAME: '$' IDENTIFIER;
IGNORED_RETURN:
	'\'' (FIELD_IDENTIFIER | IDENTIFIER | AT_VARIABLE);

NEWLINE:
	(
		'\r\n'
		| '\r'
		| '\n'
		| '\u0085' // <Next Line CHARACTER (U+0085)>'
		| '\u2028' //'<Line Separator CHARACTER (U+2028)>'
		| '\u2029'
	) -> skip; //'<Paragraph Separator CHARACTER (U+2029)>'

WHITESPACE: [ \t]+? -> skip; // skip spaces, tabs

ERROR_CHAR:
	.; //If no other tokens match. Ensures lexer does not fail and error can be handled in parser.

mode NAME_DECLARE;
NAME_IDENTIFIER:
	IDENTIFIER -> type(IDENTIFIER), pushMode(NAME_BODY);
NAME_END: '...' '.'* -> popMode;
NAME_WHITESPACE: [ \t]+? -> skip;
NAME_DECLARE_ERROR_CHAR: ERROR_CHAR -> type(ERROR_CHAR);

mode NAME_BODY;
NAME_DOLLAR_NAME:
	NEWLINE DOLLAR_NAME -> type(DOLLAR_NAME), popMode;
NAME_TEXT: .+?;
NAME_BODY_ERROR_CHAR: ERROR_CHAR -> type(ERROR_CHAR);

mode DATA_AREA;
PREFIX: 'PREFIX';
FILL: 'FILL';
DATA_SHARED: 'SHARED' -> type(SHARED);
DATA_INCLUDE: DOLLAR_INCLUDE -> type(DOLLAR_INCLUDE);
DATA_IDENTIFIER_OR_MASK:
	'@'? [a-zA-Z] [\-a-zA-Z0-9.]* -> type(IDENTIFIER);
COPY_MASK: ['] (FIELD_IDENTIFIER | IDENTIFIER);
DATA_FIELD_IDENTIFIER:
	FIELD_IDENTIFIER -> type(FIELD_IDENTIFIER);
CODE_STRING_START: 'C^' -> pushMode(CODE_STRING_MODE1);
DATA_DOLLAR_DATA: DOLLAR_DATA -> type(DOLLAR_DATA);
DATA_DOLLAR_EXTDATA: DOLLAR_EXTDATA -> type(DOLLAR_EXTDATA);
DATA_DOLLAR_SCRNDATA: DOLLAR_SCRNDATA -> type(DOLLAR_SCRNDATA);
DATA_DOLLAR_USERDATA: DOLLAR_USERDATA -> type(DOLLAR_USERDATA);
DATA_EQUAL: EQUAL -> type(EQUAL);
DATA_COMMA: COMMA -> type(COMMA);
DATA_LB: LB -> type(LB);
DATA_RB: RB -> type(RB);
DATA_LSB: LSB -> type(LSB);
DATA_RSB: RSB -> type(RSB);
DATA_STAR: STAR -> type(STAR);
DATA_ARRAY_SIZE: NUMERIC_LITERAL -> type(NUMERIC_LITERAL);
DATA_EXT: DOLLAR_EXT -> type(DOLLAR_EXT), popMode;
DATA_PROG: DOLLAR_PROG -> type(DOLLAR_PROG), popMode;
DATA_NEWLINE: NEWLINE -> type(NEWLINE);
DATA_WHITESPACE: [ \t]+? -> skip;
DATA_FULL_LINE_COMMENT:
	FULL_LINE_COMMENT -> channel(COMMENTS_CHANNEL), type(FULL_LINE_COMMENT);
DATA_END_LINE_COMMENT:
	INLINE_COMMENT -> channel(COMMENTS_CHANNEL), type(INLINE_COMMENT), pushMode(COMMENT_MODE);
DATA_AREA_ERROR_CHAR: ERROR_CHAR -> type(ERROR_CHAR);

mode CODE_STRING_MODE1;
CODE_STRING_NEWLINE:
	NEWLINE -> skip, pushMode(CODE_STRING_MODE2);
CODE_STRING_DELIM: HAT;
CODE_STRING_END: '^^' -> popMode;
CODE_STRING_TRAILING_WS:
	WHITESPACE? NEWLINE -> skip, pushMode(CODE_STRING_MODE2);
CODE_STRING_FULL_LINE_COMMENT:
	WHITESPACE? FULL_LINE_COMMENT -> channel(COMMENTS_CHANNEL), type(FULL_LINE_COMMENT);
CODE_STRING_INLINE_COMMENT:
	WHITESPACE? '<<' INPUTCHARACTER* -> channel(COMMENTS_CHANNEL), type(INLINE_COMMENT),
		pushMode(CODE_STRING_MODE2);
CODE_STRING_VALUE: NON_HAT_CHARACTER+;
CODE_STRING_MODE1_ERROR_CHAR: ERROR_CHAR -> type(ERROR_CHAR);

mode CODE_STRING_MODE2;
CODE_STRING_DELIM_2: HAT -> type(CODE_STRING_DELIM), popMode;
CODE_STRING_END_2:
	'^^' -> type(CODE_STRING_END), popMode, popMode;
CODE_STRING_TRAILING_WS2: WHITESPACE? NEWLINE -> skip;
CODE_STRING_FULL_LINE_COMMENT_2:
	WHITESPACE? FULL_LINE_COMMENT -> channel(COMMENTS_CHANNEL), type(FULL_LINE_COMMENT);
CODE_STRING_INLINE_COMMENT_2:
	WHITESPACE? INLINE_COMMENT -> channel(COMMENTS_CHANNEL), type(INLINE_COMMENT), pushMode(
		COMMENT_MODE_SKIP_NEWLINE);
CODE_STRING_WHITESPACE: WHITESPACE -> skip;
CODE_STRING_MODE2_ERROR_CHAR: ERROR_CHAR -> type(ERROR_CHAR);

mode END_OF_SOURCE;
AFTER_END_TEXT:
	FREE_TEXT -> type(FREE_TEXT), channel(COMMENTS_CHANNEL);
END_OF_SOURCE_ERROR_CHAR: ERROR_CHAR -> type(ERROR_CHAR);

mode COMMENT_MODE;
COMMENT_END1:
	'>>' -> type(INLINE_COMMENT), channel(COMMENTS_CHANNEL), popMode;
COMMENT_TEXT_SINGLE_ARROW:
	'>' -> type(INLINE_COMMENT), channel(COMMENTS_CHANNEL);
COMMENT_END2: NEWLINE -> type(NEWLINE), popMode;
COMMENT_TEXT:
	NON_RIGHT_ARROW_CHARACTER+ -> type(INLINE_COMMENT), channel(COMMENTS_CHANNEL);
FULL_LINE_COMMENT_AFTER:
	FULL_LINE_COMMENT -> type(FULL_LINE_COMMENT), channel(COMMENTS_CHANNEL), popMode;
COMMENT_MODE_ERROR_CHAR: ERROR_CHAR -> type(ERROR_CHAR);

mode COMMENT_MODE_SKIP_NEWLINE;
COMMENT_END1_SKIP:
	'>>' -> type(INLINE_COMMENT), channel(COMMENTS_CHANNEL), popMode;
COMMENT_TEXT_SINGLE_ARROW_SKIP:
	'>' -> type(INLINE_COMMENT), channel(COMMENTS_CHANNEL);
COMMENT_END2_SKIP: NEWLINE -> skip, popMode;
COMMENT_TEXT_SKIP:
	NON_RIGHT_ARROW_CHARACTER+ -> type(INLINE_COMMENT), channel(COMMENTS_CHANNEL);
FULL_LINE_COMMENT_AFTER_SKIP:
	FULL_LINE_COMMENT -> type(FULL_LINE_COMMENT), channel(COMMENTS_CHANNEL), popMode;
COMMENT_MODE_SKIP_NEWLINE_ERROR_CHAR:
	ERROR_CHAR -> type(ERROR_CHAR);

//fragments
fragment INPUTCHARACTER: ~[\r\n\u0085\u2028\u2029];

fragment NON_RIGHT_ARROW_CHARACTER: ~[>\r\n\u0085\u2028\u2029];

fragment NON_HAT_CHARACTER: ~[^\r\n\u0085\u2028\u2029];