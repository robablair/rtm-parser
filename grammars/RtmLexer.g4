lexer grammar RtmLexer;

channels {
	COMMENTS_CHANNEL
}

SOURCE_DESCRIPTION: ('RTM' | 'ZUG') INPUTCHARACTER* -> mode(SOURCE);
NON_SOURCE: . -> more, mode(TEXT_MODE);

mode TEXT_MODE;
FREE_TEXT: (.*? NL)+;

mode FOLLOWING_NEWLINE;
DOLLAR_ENTRY: '$ENTRY' -> popMode;
DOLLAR_FILES: '$FILES' -> popMode;
DOLLAR_DATA: '$DATA' -> popMode;
DOLLAR_EXTDATA: '$EXTDATA' -> popMode;
DOLLAR_SCRNDATA: '$SCRNDATA' -> popMode;
DOLLAR_USERDATA: '$USERDATA' -> popMode;
DOLLAR_EXT: '$EXT' -> popMode;
DOLLAR_INCLUDE: '$INCLUDE' -> popMode;
DOLLAR_NAME: '$NAME' -> popMode, pushMode(NAME_DECLARE);
DOLLAR_PROG: '$PROG' -> popMode;
DOLLAR_ABORT: '$ABORT' -> popMode;
DOLLAR_END: '$END' -> mode(END_OF_SOURCE);
NEWLINE_DIE: DIE -> type(DIE), popMode;
NEWLINE_QUITZUG: QUITZUG -> type(QUITZUG), popMode;
NEWLINE_RETURN: RETURN -> type(RETURN), popMode;
PROC_END: ENDPROC -> type(ENDPROC), popMode;
PROC_NAME: ID -> popMode;
FULL_LINE_COMMENT:
	'*' INPUTCHARACTER* -> channel(COMMENTS_CHANNEL), popMode;
FOLLOWING_INLINE_COMMENT:
	INLINE_COMMENT -> type(INLINE_COMMENT), channel(COMMENTS_CHANNEL), popMode, pushMode(COMMENT_MODE);
ADDITIONAL_NEWLINE: NL -> type(NL);
SOMETHING_ELSE: WS -> type(WS), channel(HIDDEN), popMode;
FOLLOWING_ERROR_CHAR: ERROR_CHAR -> type(ERROR_CHAR), popMode;

mode SOURCE;
INLINE_COMMENT:
	'<<' -> pushMode(COMMENT_MODE), channel(COMMENTS_CHANNEL);

LB: '(';
RB: ')';
COLON: ':';
SEMI_COLON: ';';
COMMA: ',';
HAT: '^';
LSB: '[';
RSB: ']';

//Assignments
ASSIGN: '_';
INCREMENT: '++';
DECREMENT: '--';
ADD_TO: '+_';

//Arithmetic
PLUS: '+';
MINUS: '-';
STAR: '*';
SLASH: '/';
DOUBLE_SLASH: '//';
SLASH_COLON: '/:';

//Logical
BIT_AND: '&';
BIT_OR: '!';
BIT_XOR: '%';
BIT_SHIFT_LEFT: '<:';
BIT_SHIFT_RIGHT: ':>';

//Relations
EQUAL: '=';
NOT_EQUAL: '#';
LESS_THAN: '<';
MORE_THAN: '>';
LESS_OR_EQUAL: '<=';
MORE_OR_EQUAL: '>=';

//Literals
NUMERIC_LITERAL: [0-9]+;
STRING_LITERAL: '"' ~["\r\n\u0085\u2028\u2029]* '"';
DATE_LITERAL: STRING_LITERAL 'D'; //handle other date masks
HEX_LITERAL: STRING_LITERAL 'X';
KEY_LITERAL: STRING_LITERAL 'K';

//Keywords
OVERLAY: 'OVERLAY';
PROC: 'PROC';
RETURN: 'RETURN';
ENDPROC: 'ENDPROC';
QUITZUG: 'QUITZUG';
DO: 'DO';
END: 'END';
CASE: 'CASE';
ENDCASE: 'ENDCASE';
ALWAYS: 'ALWAYS';
NEVER: 'NEVER';
UNTIL: 'UNTIL';
WHILE: 'WHILE';
REPEAT: 'REPEAT';
IF: 'IF';
THEN: 'THEN';
ELSE: 'ELSE';
AND: 'AND';
OR: 'OR';
SHARED: 'SHARED';
DIE: 'DIE';
PREFIX: 'PREFIX';
FILL: 'FILL';

CODE_STRING_START: 'C^' -> pushMode(CODE_STRING);
ARRAY_SIZE: NUMERIC_LITERAL -> type(NUMERIC_LITERAL);

FIELD_ID: [WFHG] [0-9]? '$' ID;
AT_VARIABLE: '@' [0-4AB];
ID: [@a-zA-Z] [\-@a-zA-Z0-9.]*;
RTMFILE_NAME: '$' ID;
APOSTROPHE_ID: '\'' (FIELD_ID | ID);

WS: [ \t] -> channel(HIDDEN);
NL:
	(
		'\r\n'
		| '\r'
		| '\n'
		| '\u0085' // <Next Line CHARACTER (U+0085)>'
		| '\u2028' //'<Line Separator CHARACTER (U+2028)>'
		| '\u2029'
	) -> pushMode(FOLLOWING_NEWLINE); //'<Paragraph Separator CHARACTER (U+2029)>'

ERROR_CHAR:
	.; //If no other tokens match. Ensures lexer does not fail and error can be handled in parser.

mode CODE_STRING;
CODE_STRING_DELIM: HAT -> type(HAT);
CODE_STRING_END: HAT HAT -> popMode;
CODE_STRING_WHITESPACE: WS+ -> type(WS);
CODE_STRING_VALUE: NON_HAT_CHARACTER+?;
CODE_STRING_NEWLINE:
	NL -> type(NL), pushMode(FOLLOWING_NEWLINE);
CODE_STRING_INLINE_COMMENT:
	'<<' -> type(INLINE_COMMENT), pushMode(COMMENT_MODE), channel(COMMENTS_CHANNEL);

mode NAME_DECLARE;
NAME_ID: ID -> type(ID), popMode, pushMode(NAME_BODY);
NAME_END: '...' '.'* -> popMode;
NAME_WHITESPACE: WS+ -> type(WS), channel(HIDDEN);
NAME_DECLARE_ERROR_CHAR: ERROR_CHAR -> type(ERROR_CHAR);

mode NAME_BODY;
NAME_TEXT: INPUTCHARACTER+ -> type(FREE_TEXT);
NAME_NEWLINE: NL -> type(FREE_TEXT), pushMode(NAME_BODY_NEWLINE);

mode NAME_BODY_NEWLINE;
NAME_DOLLAR_NAME:
	DOLLAR_NAME -> type(DOLLAR_NAME), popMode, popMode, pushMode(NAME_DECLARE);
NAME_BODY_NEWLINE_MORE: NL -> type(FREE_TEXT);
NAME_BODY_CONT: . -> type(FREE_TEXT), popMode;

mode END_OF_SOURCE;
END_TEXT:
	FREE_TEXT -> type(FREE_TEXT), channel(COMMENTS_CHANNEL);

mode COMMENT_MODE;
COMMENT_END1:
	'>>' -> type(INLINE_COMMENT), channel(COMMENTS_CHANNEL), popMode;
COMMENT_TEXT_SINGLE_ARROW:
	'>' -> type(INLINE_COMMENT), channel(COMMENTS_CHANNEL);
COMMENT_END2:
	NL -> type(NL), popMode, pushMode(FOLLOWING_NEWLINE);
COMMENT_TEXT:
	NON_RIGHT_ARROW_CHARACTER+ -> type(INLINE_COMMENT), channel(COMMENTS_CHANNEL);
COMMENT_MODE_ERROR_CHAR: ERROR_CHAR -> type(ERROR_CHAR);

//fragments
fragment INPUTCHARACTER: ~[\r\n\u0085\u2028\u2029];
fragment NON_RIGHT_ARROW_CHARACTER: ~[>\r\n\u0085\u2028\u2029];
fragment NON_HAT_CHARACTER: ~[^\r\n\u0085\u2028\u2029];