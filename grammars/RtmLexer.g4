lexer grammar RtmLexer;

channels {
	COMMENTS_CHANNEL
}

SOURCE_DESCRIPTION: ('RTM' | 'ZUG') INPUTCHARACTER* -> mode(SOURCE);
NON_SOURCE: . -> more, mode(TEXT_MODE);

mode TEXT_MODE;
FREE_TEXT: .*? EOF;

mode SOURCE;
DOLLAR_ENTRY: '$ENTRY' {Column == Text.Length}?;
DOLLAR_NAME:
	'$NAME' {Column == Text.Length}? -> pushMode(NAME_DECLARE);
DOLLAR_FILES: '$FILES' {Column == Text.Length}?;
DOLLAR_DATA:
	'$DATA' {Column == Text.Length}? -> pushMode(DATA_AREA);
DOLLAR_EXTDATA:
	'$EXTDATA' {Column == Text.Length}? -> pushMode(DATA_AREA);
DOLLAR_SCRNDATA:
	'$SCRNDATA' {Column == Text.Length}? -> pushMode(DATA_AREA);
DOLLAR_USERDATA:
	'$USERDATA' {Column == Text.Length}? -> pushMode(DATA_AREA);
DOLLAR_EXT: '$EXT' {Column == Text.Length}?;
DOLLAR_PROG: '$PROG' {Column == Text.Length}?;
DOLLAR_ABORT: '$ABORT' {Column == Text.Length}?;
DOLLAR_INCLUDE:
	'$INCLUDE' {Column == Text.Length}? -> pushMode(INCLUDE_FILE_MODE);
DOLLAR_END:
	'$END' {Column == Text.Length}? -> mode(END_OF_SOURCE);
FULL_LINE_COMMENT:
	'*' {Column == Text.Length}? INPUTCHARACTER* -> channel(COMMENTS_CHANNEL);
INLINE_COMMENT:
	'<<' -> pushMode(COMMENT_MODE), channel(COMMENTS_CHANNEL);

LB: '(';
RB: ')';
COLON: ':';
SEMI_COLON: ';';
COMMA: ',';
HAT: '^';
LSB: '[';
RSB: ']';
APOSTROPHE: '\'';

//Assignments
ASSIGN: '_';
INCREMENT: '++';
DECREMENT: '--';
ADD_TO: '+_';

//Arithmetic
PLUS: '+';
MINUS: '-';
STAR: '*';
SLASH: '/';
DOUBLE_SLASH: '//';
SLASH_COLON: '/:';

//Logical
BIT_AND: '&';
BIT_OR: '!';
BIT_XOR: '%';
BIT_SHIFT_LEFT: '<:';
BIT_SHIFT_RIGHT: ':>';

//Relations
EQUAL: '=';
NOT_EQUAL: '#';
LESS_THAN: '<';
MORE_THAN: '>';
LESS_OR_EQUAL: '<=';
MORE_OR_EQUAL: '>=';

//Literals
NUMERIC_LITERAL: [0-9]+;
STRING_LITERAL: '"' ~["\r\n\u0085\u2028\u2029]* '"';
DATE_LITERAL: STRING_LITERAL 'D'; //handle other date masks
HEX_LITERAL: STRING_LITERAL ('X'|'H');
KEY_LITERAL: STRING_LITERAL 'K';

//Keywords
OVERLAY: 'OVERLAY';
RETURN: 'RETURN';
PROC: 'PROC';
ENDPROC: 'ENDPROC';
QUITZUG: 'QUITZUG';
DO: 'DO';
END: 'END';
CASE: 'CASE';
ENDCASE: 'ENDCASE';
ALWAYS: 'ALWAYS';
NEVER: 'NEVER';
UNTIL: 'UNTIL';
WHILE: 'WHILE';
REPEAT: 'REPEAT';
IF: 'IF';
THEN: 'THEN';
ELSE: 'ELSE';
AND: 'AND';
OR: 'OR';
DIE: 'DIE';

ARRAY_SIZE: NUMERIC_LITERAL -> type(NUMERIC_LITERAL);

FIELD_ID: [WFHG] [0-9]? '$' ID;
AT_VARIABLE: '@' [0-4AB];
ID: [@a-zA-Z] [@a-zA-Z0-9.]*;
RTMFILE_NAME: '$' ID;
IGNORED_RETURN: APOSTROPHE (FIELD_ID | ID);

WS: WHITESPACE+ -> channel(HIDDEN);
NL:
	(
		'\r\n'
		| '\r'
		| '\n'
		| '\u0085' // <Next Line CHARACTER (U+0085)>'
		| '\u2028' //'<Line Separator CHARACTER (U+2028)>'
		| '\u2029'
	); //'<Paragraph Separator CHARACTER (U+2029)>'

ERROR_CHAR:
	.; //If no other tokens match. Ensures lexer does not fail and error can be handled in parser.

mode DATA_AREA;
SHARED: 'SHARED';
PREFIX: 'PREFIX';
FILL: 'FILL';
DATA_INCLUDE:
	DOLLAR_INCLUDE -> type(DOLLAR_INCLUDE), pushMode(INCLUDE_FILE_MODE);
DATA_ID_OR_MASK: [@a-zA-Z] [\-@a-zA-Z0-9.]* (PLUS NUMERIC_LITERAL)?;
COPY_MASK: APOSTROPHE WS? (FIELD_ID | ID);
DATA_FIELD_ID: FIELD_ID -> type(FIELD_ID);
CODE_STRING_START: 'C' WS? '^' -> pushMode(CODE_STRING);
DATA_DOLLAR_DATA: DOLLAR_DATA -> type(DOLLAR_DATA);
DATA_DOLLAR_EXTDATA: DOLLAR_EXTDATA -> type(DOLLAR_EXTDATA);
DATA_DOLLAR_SCRNDATA: DOLLAR_SCRNDATA -> type(DOLLAR_SCRNDATA);
DATA_DOLLAR_USERDATA: DOLLAR_USERDATA -> type(DOLLAR_USERDATA);
DATA_EXT: DOLLAR_EXT -> type(DOLLAR_EXT), popMode;
DATA_PROG: DOLLAR_PROG -> type(DOLLAR_PROG), popMode;
DATA_EQUAL: EQUAL -> type(EQUAL);
DATA_COMMA: COMMA -> type(COMMA);
DATA_LB: LB -> type(LB);
DATA_RB: RB -> type(RB);
DATA_LSB: LSB -> type(LSB);
DATA_RSB: RSB -> type(RSB);
DATA_ARRAY_SIZE: NUMERIC_LITERAL -> type(NUMERIC_LITERAL);
DATA_NEWLINE: NL -> type(NL);
DATA_WHITESPACE: WHITESPACE+? -> channel(HIDDEN);
DATA_FULL_LINE_COMMENT:
	FULL_LINE_COMMENT -> channel(COMMENTS_CHANNEL), type(FULL_LINE_COMMENT);
DATA_END_LINE_COMMENT:
	INLINE_COMMENT -> channel(COMMENTS_CHANNEL), type(INLINE_COMMENT), pushMode(COMMENT_MODE);
DATA_STAR: STAR -> type(STAR);
DATA_ERROR_CHAR: ERROR_CHAR -> type(ERROR_CHAR);

mode CODE_STRING;
CODE_STRING_DELIM: HAT -> type(HAT);
CODE_STRING_END: HAT HAT -> popMode;
CODE_STRING_WHITESPACE: WS -> type(WS);
CODE_STRING_VALUE: NON_HAT_CHARACTER+?;
CODE_STRING_NEWLINE: NL -> type(NL);
CODE_STRING_FULL_LINE_COMMENT:
	FULL_LINE_COMMENT -> type(FULL_LINE_COMMENT), channel(COMMENTS_CHANNEL);
CODE_STRING_INLINE_COMMENT:
	'<<' -> type(INLINE_COMMENT), pushMode(COMMENT_MODE), channel(COMMENTS_CHANNEL);

mode INCLUDE_FILE_MODE;
INCLUDE_FILENAME: (
		VALID_FILENAME_CHARACTER_NO_SPACE_OR_PAREN+
		| STAR
	);
INCLUDE_LB:
	LB -> type(LB), popMode, pushMode(INCLUDE_NAME_MODE);
INCLUDE_FILE_END: NL -> type(NL), popMode;
INCLUDE_FILE_INLINE_COMMENT:
	INLINE_COMMENT -> type(INLINE_COMMENT), popMode, pushMode(COMMENT_MODE), channel(COMMENTS_CHANNEL);
INCLUDE_FILE_WHITESPACE: WS+? -> skip;
INCLUDE_FILE_ERROR_CHAR: ERROR_CHAR -> type(ERROR_CHAR);

mode INCLUDE_NAME_MODE;
INCLUDE_NAME: NON_RB_OR_SPACE_CHARACTER+;
INCLUDE_RB:
	RB -> type(RB), popMode, pushMode(IGNORE_REST_OF_LINE);
INCLUDE_NAME_SPACE:
	WHITESPACE -> more, popMode, pushMode(IGNORE_REST_OF_LINE);
INCLUDE_NAME_END: NL -> type(NL), popMode;
INCLUDE_NAME_FULL_LINE_COMMENT:
	FULL_LINE_COMMENT -> channel(COMMENTS_CHANNEL), type(FULL_LINE_COMMENT), popMode;
INCLUDE_NAME_ERROR_CHAR: ERROR_CHAR -> type(ERROR_CHAR);

mode NAME_DECLARE;
NAME_ID:
	ID -> popMode, pushMode(NAME_BODY), pushMode(IGNORE_REST_OF_LINE);
NAME_END:
	'...' -> popMode, pushMode(AFTER_NAME_END), pushMode(IGNORE_REST_OF_LINE);
NAME_WHITESPACE: WS -> type(WS), channel(HIDDEN);
NAME_DECLARE_ERROR_CHAR: ERROR_CHAR -> type(ERROR_CHAR);

mode NAME_BODY;
NAME_TEXT: . -> type(FREE_TEXT);
NAME_DOLLAR_NAME:
	DOLLAR_NAME -> type(DOLLAR_NAME), popMode, pushMode(NAME_DECLARE);

mode AFTER_NAME_END;
AFTER_NAME_DOLLAR_ENTRY:
	DOLLAR_ENTRY -> type(DOLLAR_ENTRY), popMode;
AFTER_DOLLAR_NAME: DOLLAR_NAME -> type(DOLLAR_NAME), popMode, pushMode(NAME_DECLARE);
AFTER_DOLLAR_FILES: DOLLAR_FILES -> type(DOLLAR_FILES), popMode;
AFTER_DOLLAR_DATA: DOLLAR_DATA -> type(DOLLAR_DATA), popMode, pushMode(DATA_AREA);
AFTER_DOLLAR_EXTDATA: DOLLAR_EXTDATA -> type(DOLLAR_EXTDATA), popMode, pushMode(DATA_AREA);
AFTER_DOLLAR_SCRNDATA: DOLLAR_SCRNDATA -> type(DOLLAR_SCRNDATA), popMode, pushMode(DATA_AREA);
AFTER_DOLLAR_USERDATA: DOLLAR_USERDATA -> type(DOLLAR_USERDATA), popMode, pushMode(DATA_AREA);
AFTER_DOLLAR_EXT: DOLLAR_EXT -> type(DOLLAR_EXT), popMode;
AFTER_DOLLAR_PROG: DOLLAR_PROG -> type(DOLLAR_PROG), popMode;
AFTER_DOLLAR_ABORT: DOLLAR_ABORT -> type(DOLLAR_ABORT), popMode;
AFTER_DOLLAR_INCLUDE: DOLLAR_INCLUDE -> type(DOLLAR_INCLUDE), popMode, pushMode(INCLUDE_FILE_MODE);
AFTER_DOLLAR_END: DOLLAR_END -> type(DOLLAR_END), popMode, mode(END_OF_SOURCE);
AFTER_NAME_FREE_TEXT:
	.+? -> type(FREE_TEXT), channel(COMMENTS_CHANNEL);

mode IGNORE_REST_OF_LINE;
POST_INCLUDE_FREE_TEXT:
	INPUTCHARACTER+ -> type(INLINE_COMMENT), channel(COMMENTS_CHANNEL);
POST_INCLUDE_NEWLINE: NL -> type(NL), popMode;

mode END_OF_SOURCE;
END_TEXT:
	FREE_TEXT -> type(FREE_TEXT), channel(COMMENTS_CHANNEL);

mode COMMENT_MODE;
COMMENT_END1:
	'>>' -> type(INLINE_COMMENT), channel(COMMENTS_CHANNEL), popMode;
COMMENT_TEXT_SINGLE_ARROW:
	'>' -> type(INLINE_COMMENT), channel(COMMENTS_CHANNEL);
COMMENT_END2: NL -> type(NL), popMode;
COMMENT_TEXT:
	NON_RIGHT_ARROW_CHARACTER+ -> type(INLINE_COMMENT), channel(COMMENTS_CHANNEL);
COMMENT_MODE_ERROR_CHAR: ERROR_CHAR -> type(ERROR_CHAR);

//fragments
fragment WHITESPACE: [ \t];
fragment INPUTCHARACTER: ~[\r\n\u0085\u2028\u2029];
fragment NON_RIGHT_ARROW_CHARACTER: ~[>\r\n\u0085\u2028\u2029];
fragment NON_HAT_CHARACTER: ~[^\r\n\u0085\u2028\u2029];
fragment NON_RB_OR_SPACE_CHARACTER:
	~[) \t\r\n\u0085\u2028\u2029];
fragment VALID_FILENAME_CHARACTER_NO_SPACE_OR_PAREN:
	~[ ()<>:"/\\|?*\t\r\n\u0085\u2028\u2029];