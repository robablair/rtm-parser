lexer grammar RtmLexer;

channels {
	COMMENTS_CHANNEL
}

SOURCE_TYPE: (RTM | ZUG) -> pushMode(SOURCE_DESCRIPTION);

FULL_LINE_COMMENT:
	NEWLINE '*' INPUTCHARACTER* -> channel(COMMENTS_CHANNEL);
INLINE_COMMENT:
	'<<' -> pushMode(COMMENT_MODE_SKIP_NEWLINE), channel(COMMENTS_CHANNEL);

DOLLAR_ENTRY: DOLLAR ENTRY;
DOLLAR_FILES: DOLLAR FILES;
DOLLAR_DATA: DOLLAR DATA -> pushMode(DATA_AREA);
DOLLAR_DATA_SHARED: DOLLAR DATA_SHARED -> pushMode(DATA_AREA);
DOLLAR_EXTDATA: DOLLAR EXTDATA -> pushMode(DATA_AREA);
DOLLAR_SCRNDATA: DOLLAR SCRNDATA -> pushMode(DATA_AREA);
DOLLAR_USERDATA: DOLLAR USERDATA -> pushMode(DATA_AREA);
DOLLAR_EXT: DOLLAR EXT;
DOLLAR_INCLUDE: DOLLAR INCLUDE;
DOLLAR_NAME: DOLLAR NAME -> pushMode(NAME_DECLARE);
DOLLAR_PROG: DOLLAR PROG;
DOLLAR_ABORT: DOLLAR ABORT;
DOLLAR_END: DOLLAR END -> pushMode(END_OF_SOURCE);

LB: '(';
RB: ')';
COLON: ':';
SEMI_COLON: ';';
COMMA: ',';
DOLLAR: '$';
HAT: '^';
AT: '@';
LSB: '[';
RSB: ']';
DOT: '.';
ELLIPSIS: '...';

//Assignments
ASSIGN: '_';
INCREMENT: '++';
DECREMENT: '--';
ADD_TO: '+_';

//Arithmetic
PLUS: '+';
MINUS: '-';
STAR: '*';
SLASH: '/';
DOUBLE_SLASH: '//';
SLASH_COLON: '/:';

//Logical
BIT_AND: '&';
BIT_OR: '!';
BIT_XOR: '%';
BIT_SHIFT_LEFT: '<:';
BIT_SHIFT_RIGHT: ':>';

//Relations
EQUAL: '=';
NOT_EQUAL: '#';
LESS_THAN: '<';
MORE_THAN: '>';
LESS_OR_EQUAL: '<=';
MORE_OR_EQUAL: '>=';

//Literals
NUMERIC_LITERAL: [0-9]+;
STRING_LITERAL: '"' ~["\\\r\n\u0085\u2028\u2029]* '"';
DATE_LITERAL: STRING_LITERAL 'D';
HEX_LITERAL: STRING_LITERAL 'X';

//Keywords
RTM: 'RTM';
ZUG: 'ZUG';
OVERLAY: 'OVERLAY';
PROC: 'PROC';
RETURN: 'RETURN';
ENDPROC: 'ENDPROC';
QUITZUG: 'QUITZUG';
DO: 'DO';
END: 'END';
CASE: 'CASE';
ENDCASE: 'ENDCASE';
ALWAYS: 'ALWAYS';
NEVER: 'NEVER';
UNTIL: 'UNTIL';
WHILE: 'WHILE';
REPEAT: 'REPEAT';
EXIT: 'EXIT';
IF: 'IF';
THEN: 'THEN';
ELSE: 'ELSE';
AND: 'AND';
OR: 'OR';
ENTRY: 'ENTRY';
ABORT: 'ABORT';
DATA: 'DATA';
DATA_SHARED: 'DATA,SHARED';
EXT: 'EXT';
EXTDATA: 'EXTDATA';
EXTRACT: 'EXTRACT';
FILE: 'FILE';
FILES: 'FILES';
INCLUDE: 'INCLUDE';
LIVE: 'LIVE';
LIVEUSER: 'LIVEUSER';
NAME: 'NAME';
NEWCLUSTERS: 'NEWCLUSTERS';
OPT: 'OPT';
PROG: 'PROG';
RECORD: 'RECORD';
SCRNDATA: 'SCRNDATA';
SNAPSHOT: 'SNAPSHOT';
TEST: 'TEST';
TESTUSER: 'TESTUSER';
USERDATA: 'USERDATA';
DOWN: 'DOWN';
ERASE: 'ERASE';
CR: 'CR';
BACK: 'BACK';
BEEP: 'BEEP';
CLEAR: 'CLEAR';
LEFT: 'LEFT';
RIGHT: 'RIGHT';
TABSTOP: 'TABSTOP';
UP: 'UP';
FLASH: 'FLASH';
HI: 'HI';
LO: 'LO';
KEYED: 'KEYED';
NOABORT: 'NOABORT';
ALLOC: 'ALLOC';
COPYR: 'COPYR';
INDEX: 'INDEX';
LOCK: 'LOCK';
NOGROUP: 'NOGROUP';
PACK: 'PACK';
READ: 'READ';
READLOCK: 'READLOCK';
REF: 'REF';
RELEASE: 'RELEASE';
SEGPTR: 'SEGPTR';
TESTLOCK: 'TESTLOCK';
UNLOCK: 'UNLOCK';
WRITE: 'WRITE';
UNPACK: 'UNPACK';
BNUM: 'BNUM';
DELETE: 'DELETE';
INIT: 'INIT';
APPLY: 'APPLY';
CONCAT: 'CONCAT';
CONVERT: 'CONVERT';
LENGTH: 'LENGTH';
MATCH: 'MATCH';
TRANSLATE: 'TRANSLATE';
SUBSTR: 'SUBSTR';
ABS: 'ABS';
EXP2: 'EXP2';
MAX: 'MAX';
MIN: 'MIN';
RANDOM: 'RANDOM';
REM: 'REM';
ALTSCR: 'ALTSCR';
DISCARD: 'DISCARD';
ERROR: 'ERROR';
DIE: 'DIE';
RC: 'RC';
TRUNC: 'TRUNC';
WAIT: 'WAIT';
VID: 'VID';
IN: 'IN';
INFLD: 'INFLD';
INOPT: 'INOPT';
SETOPT: 'SETOPT';
VALID: 'VALID';
OUT: 'OUT';
SETERR: 'SETERR';
FIXERRS: 'FIXERRS';
OUTIF: 'OUTIF';
OUTIMM: 'OUTIMM';
OUTONLY: 'OUTONLY';
ADD: 'ADD';
DEL: 'DEL';
FIRST: 'FIRST';
NEXT: 'NEXT';
FIND: 'FIND';
FND: 'FND';

FIELD_IDENTIFIER: [WFHG] [0-9]? DOLLAR IDENTIFIER;
AT_VARIABLE: '@' [0-4AB];
IDENTIFIER: '@'? [a-zA-Z] [a-zA-Z0-9.]*;
RTMFILE_NAME: DOLLAR IDENTIFIER;
IGNORED_RETURN:
	'\'' (FIELD_IDENTIFIER | IDENTIFIER | AT_VARIABLE);

NEWLINE:
	(
		'\r\n'
		| '\r'
		| '\n'
		| '\u0085' // <Next Line CHARACTER (U+0085)>'
		| '\u2028' //'<Line Separator CHARACTER (U+2028)>'
		| '\u2029'
	) -> skip; //'<Paragraph Separator CHARACTER (U+2029)>'

WHITESPACE: [ \t]+? -> skip; // skip spaces, tabs

mode SOURCE_DESCRIPTION;
SOURCE_DESCRIPTION_SKIP: NEWLINE -> skip, popMode;
SOURCE_DESC: INPUTCHARACTER+ -> popMode;

mode NAME_DECLARE;
NAME_IDENTIFIER:
	IDENTIFIER -> type(IDENTIFIER), pushMode(NAME_BODY);
NAME_END: '...' '.'* -> popMode;
NAME_WHITESPACE: [ \t]+? -> skip;

mode NAME_BODY;
NAME_DOLLAR_NAME:
	NEWLINE DOLLAR_NAME -> type(DOLLAR_NAME), popMode;
NAME_TEXT: .+?;

mode DATA_AREA;
DATA_INCLUDE: DOLLAR_INCLUDE -> type(DOLLAR_INCLUDE);
DATA_GENERAL_ID: [a-zA-Z] [a-zA-Z0-9.]* -> type(IDENTIFIER);
COPY_MASK: ['] (FIELD_IDENTIFIER | IDENTIFIER);
DATA_FIELD_IDENTIFIER:
	FIELD_IDENTIFIER -> type(FIELD_IDENTIFIER);
CODE_STRING_START: 'C^' -> pushMode(CODE_STRING_MODE1);
DATA_DOLLAR_DATA: DOLLAR_DATA -> type(DOLLAR_DATA);
DATA_DOLLAR_DATA_SHARED:
	DOLLAR_DATA_SHARED -> type(DOLLAR_DATA_SHARED);
DATA_DOLLAR_EXTDATA: DOLLAR_EXTDATA -> type(DOLLAR_EXTDATA);
DATA_DOLLAR_SCRNDATA: DOLLAR_SCRNDATA -> type(DOLLAR_SCRNDATA);
DATA_DOLLAR_USERDATA: DOLLAR_USERDATA -> type(DOLLAR_USERDATA);
PREFIX: 'PREFIX';
FILL: 'FILL';
DATA_EQUAL: EQUAL -> type(EQUAL);
DATA_COMMA: COMMA -> type(COMMA);
DATA_LB: LB -> type(LB);
DATA_RB: RB -> type(RB);
DATA_LSB: LSB -> type(LSB);
DATA_RSB: RSB -> type(RSB);
DATA_STAR: STAR -> type(STAR);
DATA_ARRAY_SIZE: NUMERIC_LITERAL -> type(NUMERIC_LITERAL);
DATA_EXT: DOLLAR_EXT -> type(DOLLAR_EXT), popMode;
DATA_PROG:
	DOLLAR_PROG -> type(DOLLAR_PROG), popMode;
DATA_NEWLINE: NEWLINE -> type(NEWLINE);
DATA_WHITESPACE: [ \t]+? -> skip;
DATA_FULL_LINE_COMMENT:
	FULL_LINE_COMMENT -> channel(COMMENTS_CHANNEL), type(FULL_LINE_COMMENT);
DATA_END_LINE_COMMENT:
	INLINE_COMMENT -> channel(COMMENTS_CHANNEL), type(INLINE_COMMENT), pushMode(COMMENT_MODE);

mode CODE_STRING_MODE1;
CODE_STRING_VALUE: NON_HAT_CHARACTER+;
CODE_STRING_NEWLINE: NEWLINE -> skip, pushMode(CODE_STRING_MODE2);
CODE_STRING_DELIM: HAT;
CODE_STRING_END: '^^' -> popMode;
CODE_STRING_TRAILING_WS:
	WHITESPACE NEWLINE -> skip, pushMode(CODE_STRING_MODE2);
CODE_STRING_FULL_LINE_COMMENT:
	WHITESPACE FULL_LINE_COMMENT -> channel(COMMENTS_CHANNEL), type(FULL_LINE_COMMENT);
CODE_STRING_END_LINE_COMMENT:
	WHITESPACE INLINE_COMMENT -> channel(COMMENTS_CHANNEL), type(INLINE_COMMENT), pushMode(COMMENT_MODE);

mode CODE_STRING_MODE2;
CODE_STRING_DELIM_2:
	HAT -> type(CODE_STRING_DELIM), popMode;
CODE_STRING_END_2:
	'^^' -> type(CODE_STRING_END), popMode, popMode;
CODE_STRING_TRAILING_WS2: WHITESPACE NEWLINE -> skip;
CODE_STRING_FULL_LINE_COMMENT_2:
	WHITESPACE FULL_LINE_COMMENT -> channel(COMMENTS_CHANNEL), type(FULL_LINE_COMMENT);
CODE_STRING_END_LINE_COMMENT_2:
	WHITESPACE INLINE_COMMENT -> channel(COMMENTS_CHANNEL), type(INLINE_COMMENT), pushMode(COMMENT_MODE);
CODE_STRING_WHITESPACE: WHITESPACE -> skip;

mode END_OF_SOURCE;
FREE_TEXT:
	INPUTCHARACTER* (NEWLINE | EOF) -> channel(COMMENTS_CHANNEL);

mode COMMENT_MODE;
COMMENT_END1:
	'>>' -> type(INLINE_COMMENT), channel(COMMENTS_CHANNEL), popMode;
COMMENT_TEXT_SINGLE_ARROW:
	'>' -> type(INLINE_COMMENT), channel(COMMENTS_CHANNEL);
COMMENT_END2: NEWLINE -> type(NEWLINE), popMode;
COMMENT_TEXT:
	NON_RIGHT_ARROW_CHARACTER+ -> type(INLINE_COMMENT), channel(COMMENTS_CHANNEL);
FULL_LINE_COMMENT_AFTER:
	FULL_LINE_COMMENT -> type(FULL_LINE_COMMENT), channel(COMMENTS_CHANNEL), popMode;

mode COMMENT_MODE_SKIP_NEWLINE;
COMMENT_END1_SKIP:
	'>>' -> type(INLINE_COMMENT), channel(COMMENTS_CHANNEL), popMode;
COMMENT_TEXT_SINGLE_ARROW_SKIP:
	'>' -> type(INLINE_COMMENT), channel(COMMENTS_CHANNEL);
COMMENT_END2_SKIP: NEWLINE -> skip, popMode;
COMMENT_TEXT_SKIP:
	NON_RIGHT_ARROW_CHARACTER+ -> type(INLINE_COMMENT), channel(COMMENTS_CHANNEL);
FULL_LINE_COMMENT_AFTER_SKIP:
	FULL_LINE_COMMENT -> type(FULL_LINE_COMMENT), channel(COMMENTS_CHANNEL), popMode;

//fragments
fragment INPUTCHARACTER: ~[\r\n\u0085\u2028\u2029];

fragment NON_RIGHT_ARROW_CHARACTER: ~[>\r\n\u0085\u2028\u2029];

fragment NON_HAT_CHARACTER: ~[^\r\n\u0085\u2028\u2029];